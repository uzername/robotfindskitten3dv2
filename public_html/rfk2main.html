<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>ROBOTFINDSKITTEN</title>
		<style>
			html, body {
				width: 100%;
				height: 100%;
			}

			body {
				background-color: #ffffff;
				margin: 0;
				overflow: hidden;
				font-family: arial;
			}

			#blocker {
				position: absolute;
				width: 100%;
				height: 100%;
				background-color: rgba(0,0,0,0.5);

			}
                        #info {
                            width:100%;
                            text-align: center;
                            position: absolute;
                            top:0;
                            z-index: 3;
                        }
			#instructions {

				width: 100%;
				height: 100%;

				display: -webkit-box;
				display: -moz-box;
				display: box;

				-webkit-box-orient: horizontal;
				-moz-box-orient: horizontal;
				box-orient: horizontal;

				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;

				-webkit-box-align: center;
				-moz-box-align: center;
				box-align: center;

				color: #ffffff;
				text-align: center;

				cursor: pointer;

			}

		</style>
	</head>
	<body>
		<script src="three.min.js"></script>
		<script src="PointerLockControls.js"></script>
                <script src="threex.dynamictexture.js"></script>
                <script type="text/javascript" src="itmloader2.js"> </script>
                <script type="text/javascript" src="gridCollision.js"> </script>
                <div id="info">YAY!</div>
		<div id="blocker">

			<div id="instructions">
                                " 'GO!' I told the box as it began to roll out of my workshop into the frozen desert beyond. 'FIND 
KITTEN!' " <br /> The Book of Found Kittens, pages 43-4, author unknown <br /> <br/>
				<span style="font-size:40px">Click to play</span>
				<br />
				(W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)
			</div>

		</div>

		<script>
                            function degInRad(deg) {
                                return deg * Math.PI / 180;
                            }
                        
                            function getRandomInt(min, max) {
                                return Math.floor(Math.random() * (max - min + 1)) + min;
                            }
                            function random_character() {
                                var chars = "0123456789abcdefghijklmnopqurstuvwxyzABCDEFGHIJKLMNOPQURSTUVWXYZ\'.,*()+-=[]{}:;~%/";
                                return chars.substr( Math.floor(Math.random() * 81), 1);
                            }

                        var nkicollection = loadbase2("itmbase2.xml");
                        //console.log(nkicollection);
                            var availableNKIindexes; 
                            
			var camera, scene, renderer;
			var geometry, material, mesh;
			var controls;
			var objects = [];
                        
                        var palette = ["red", "yellow", "green", "blue", "cyan", "purple", "brown"];
                        var pLength = palette.length-1;
                        
			var raycaster;
                        var rays;
                        var bottomVector;
			var blocker = document.getElementById( 'blocker' );
			var instructions = document.getElementById( 'instructions' );                     
                        var planedepth; var planewidth; var nkiNum;
                        var myUnitSz=20;
                        var controlsHeight=myUnitSz;
                        var allNKI; //array of Basic NKI. sparse array. It's ok, it won't use much memory. hmm. might be used for collision detection too
                        var prevPosition=new THREE.Vector3(0,0,0);
                        
                        function BasicNKI(xcoord, ycoord, descrline, inpContentIndx) { //basic struct for NKI
                            /*integer (logic) coordinates of NKI*/
                            this.X = xcoord;
                            this.Y = ycoord;
                            //a symbol of NKI
                            this.descr = descrline;
                            this.content=inpContentIndx;
                        }
                        //THREEJS and WebGL init routines
                        function defPlane(w, h, rtAngleDeg, texPath, texMode, centerPos) {
                            var GenericPlane = new THREE.PlaneGeometry( w, h );
                            var floorTexture = THREE.ImageUtils.loadTexture(texPath);
                            if (texMode!=null) {
                                floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
                                floorTexture.repeat.set( texMode.x, texMode.y ); }
                            material = new THREE.MeshLambertMaterial({map: floorTexture, side:THREE.DoubleSide});
                            var yobaplane = new THREE.Mesh( GenericPlane, material );
                            yobaplane.position.x=centerPos.x; yobaplane.position.y=centerPos.y; yobaplane.position.z=centerPos.z;
                            yobaplane.rotateOnAxis(new THREE.Vector3(1, 0, 0), degInRad(rtAngleDeg.x));
                            yobaplane.rotateOnAxis(new THREE.Vector3(0, 1, 0), degInRad(rtAngleDeg.y));
                            yobaplane.rotateOnAxis(new THREE.Vector3(0, 0, 1), degInRad(rtAngleDeg.z));
                            return yobaplane;
                        }
                        function checkCollisionGrid(inpHorizontalPoint1, inpVerticalPoint1) {
                            for(var i=0; i<allCollisionsArray.length; i++) {
                                if (allCollisionsArray[i].testCollide(inpHorizontalPoint1,inpVerticalPoint1)!==null) {
                                    /*console.log("horizontal: "+inpHorizontalPoint1+" verical: "+inpVerticalPoint1);*/
                                    /*console.log("array: ");*/
                                    /*console.log(allCollisionsArray[i]);*/
                                    return allCollisionsArray[i];
                                }
                            }
                            return null;
                        }
                        function initFloor() {
                            geometry = new THREE.PlaneGeometry( 2000, 2000, 100, 100 );
                            geometry.rotateX( - Math.PI / 2 );
				for ( var i = 0, l = geometry.vertices.length; i < l; i ++ ) {
					var vertex = geometry.vertices[ i ];
					vertex.x += Math.random() * 20 - 10;
					vertex.y += Math.random() * 2;
					vertex.z += Math.random() * 20 - 10;
				}

				for ( var i = 0, l = geometry.faces.length; i < l; i ++ ) {
					var face = geometry.faces[ i ];
					face.vertexColors[ 0 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
					face.vertexColors[ 1 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
					face.vertexColors[ 2 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
				}

				material = new THREE.MeshBasicMaterial( { vertexColors: THREE.VertexColors } );

				mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );
                        }
                        function initFloor2() {
                            yobaplane2=defPlane(planewidth*myUnitSz, planedepth*myUnitSz, new THREE.Vector3(90,0,0), 
                                                'graphon/inside_floor.jpg', new function() {this.x=planewidth; this.y=planedepth;}, 
                                                new THREE.Vector3(0,0,0));
                            scene.add( yobaplane2 ); yobaplane2.name="yobaplane2";
                        }
                        //===dynamic textures and objects===
                        function initTextureFromText(txt, bracketedFontColor) {
                            // create canvas
                            var canvas = document.createElement('canvas');
                            // the larger these numbers, the larger the canvas, and
                            // the smoother your final image can be. If your final
                            // texture is blurry or pixelated, try increasing these
                            // numbers, and drawing on the canvas in a larger font.
                            canvas.width = 100;
                            canvas.height = 100;
                            // draw the score of "50" to the canvas
                            var context = canvas.getContext('2d');
                            /*context.fillStyle = 'rgba(0, 255, 0, 0.01)';
                            context.fillRect(0, 0, canvas.width, canvas.height);*/
                            context.font = "Bold 100px Monospace";
                            context.fillStyle = "rgba"+bracketedFontColor;
                            context.fillText(txt, 0, 100);
                            // use canvas contents as a texture
                            var texture = new THREE.Texture(canvas);
                            texture.needsUpdate = true;
                            return texture;
                        }
                        function addTextPlane(retTexture) {
                            var geometry = new THREE.PlaneGeometry(100, 100, 1, 1);
                            var material = new THREE.MeshBasicMaterial( {
                                    map: retTexture, side:THREE.DoubleSide
                            } );
                            material.transparent=true;
                            var plane = new THREE.Mesh( geometry, material );
                            return plane;
                        }
                        //adding single NKI to the field by the given set of coordinates
                        //these coordinates are expressed in myUnitSz integer values, 
                        //not in the absolute coordinates in 3D space
                        
                        function addSingleNKI(unitZ, unitX, NKISymbol) {
                            var geometryBase = new THREE.BoxGeometry( myUnitSz, myUnitSz/4, myUnitSz );
                            var material1 = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
                            var cube1 = new THREE.Mesh(geometryBase, material1);
                            scene.add(cube1);
                            cube1.position.setX(unitX*myUnitSz);
                            cube1.position.setZ(unitZ*myUnitSz);
                            cube1.position.setY(myUnitSz/8);
                            
                            var geometryStalk = new THREE.BoxGeometry( 2*myUnitSz/3, myUnitSz*2, 2*myUnitSz/3 );
                            var cube0 = new THREE.Mesh(geometryStalk, material1);
                            scene.add(cube0);
                            cube0.position.setX(unitX*myUnitSz);
                            cube0.position.setZ(unitZ*myUnitSz);
                            cube0.position.setY(myUnitSz);
                            
                            var cube2 = new THREE.Mesh(geometryBase, material1);
                            scene.add(cube2);
                            cube2.position.setX(unitX*myUnitSz);
                            cube2.position.setZ(unitZ*myUnitSz);
                            cube2.position.setY(16*myUnitSz/8);
                            
                            var myTexture=initTextureFromText(NKISymbol, "(255,0,0,0.95)");
                            var geometryText = new THREE.PlaneGeometry(myUnitSz*1, myUnitSz*2, 1, 1);
                            var materialText = new THREE.MeshBasicMaterial( {
                                    map: myTexture, side:THREE.DoubleSide
                            } );
                            
                            materialText.transparent=true;                            
                            var planeText1 = new THREE.Mesh( geometryText, materialText );
                            scene.add(planeText1);
                            planeText1.position.setX((unitX+1/4)*myUnitSz);
                            planeText1.position.setZ((unitZ+1/2)*myUnitSz+1);
                            planeText1.position.setY(myUnitSz*1.5);
                            
                            var planeText2 = new THREE.Mesh( geometryText, materialText );
                            scene.add(planeText2);
                            planeText2.position.setX((unitX-1/4)*myUnitSz);
                            planeText2.position.setZ((unitZ-1/2)*myUnitSz-1);
                            planeText2.position.setY(myUnitSz*1.5);
                            planeText2.rotateY(Math.PI);
                            
                            var planeText3 = new THREE.Mesh( geometryText, materialText );
                            scene.add(planeText3);
                            planeText3.position.setX((unitX-1/2)*myUnitSz-1);
                            planeText3.position.setZ((unitZ+1/4)*myUnitSz);
                            planeText3.position.setY(myUnitSz*1.5);
                            planeText3.rotateY(3*Math.PI/2);
                            
                            var planeText4 = new THREE.Mesh( geometryText, materialText );
                            scene.add(planeText4);
                            planeText4.position.setX((unitX+1/2)*myUnitSz+1);
                            planeText4.position.setZ((unitZ-1/4)*myUnitSz);
                            planeText4.position.setY(myUnitSz*1.5);
                            planeText4.rotateY(Math.PI/2);
                        }
                        /*actual subroutine to draw NKI (or just item, because they are the same during gameplay)*/
                        function addSingleNKI2(unitZ, unitX, NKISymbol, NKIColor) {
                            var geometryBase = new THREE.BoxGeometry( myUnitSz, myUnitSz/4, myUnitSz );
                            var textureBase = THREE.ImageUtils.loadTexture( 'graphon/floor2.jpg' );
                            var material1 = new THREE.MeshBasicMaterial( {map: textureBase} );
                            var cube1 = new THREE.Mesh(geometryBase, material1);
                            scene.add(cube1);
                            cube1.position.setX(unitX*myUnitSz);
                            cube1.position.setZ(unitZ*myUnitSz);
                            cube1.position.setY(myUnitSz/8);
                            
                            var dynamicTexture	= new THREEx.DynamicTexture(10*2*myUnitSz/3,10*myUnitSz*2/3);
                            dynamicTexture.context.font	= "bolder "+myUnitSz*4+"px Verdana";
                            dynamicTexture.texture.anisotropy = renderer.getMaxAnisotropy();
                            dynamicTexture.clear('transparent').drawText(NKISymbol, undefined, 4*myUnitSz, NKIColor);
                            //dynamicTexture.addTexture('graphon/ScreenFinal2Small.png').drawText(NKISymbol, undefined, 4*myUnitSz, 'red');
                            var letterMaterial	= new THREE.MeshBasicMaterial({map:dynamicTexture.texture, transparent:true});
                            letterMaterial.side = THREE.DoubleSide;
                            var geometryPlane = new THREE.PlaneGeometry( 2*myUnitSz/3, myUnitSz*2, 2*myUnitSz/3);
                            var plane1=new THREE.Mesh( geometryPlane, letterMaterial );
                            scene.add(plane1);
                            plane1.position.setX(unitX*(myUnitSz));
                            plane1.position.setZ((unitZ+4/9)*(myUnitSz));
                            plane1.position.setY(myUnitSz);
                            var plane2=new THREE.Mesh( geometryPlane, letterMaterial );
                            scene.add(plane2);
                            plane2.position.setX(unitX*(myUnitSz));
                            plane2.position.setZ((unitZ-4/9)*(myUnitSz));
                            plane2.position.setY(myUnitSz);
                            plane2.rotateOnAxis(new THREE.Vector3(0, 1, 0), degInRad(180));
                            
                            var plane3=new THREE.Mesh(geometryPlane, letterMaterial);
                            scene.add(plane3);
                            plane3.position.setX((unitX+4/9)*(myUnitSz));
                            plane3.position.setZ(unitZ*(myUnitSz));
                            plane3.position.setY(myUnitSz);
                            plane3.rotateOnAxis(new THREE.Vector3(0, 1, 0), degInRad(90));
                            var plane4=new THREE.Mesh(geometryPlane, letterMaterial);
                            scene.add(plane4);
                            plane4.position.setX((unitX-4/9)*(myUnitSz));
                            plane4.position.setZ(unitZ*(myUnitSz));
                            plane4.position.setY(myUnitSz);
                            plane4.rotateOnAxis(new THREE.Vector3(0, 1, 0), degInRad(270));
                            
                            var textureStalk = THREE.ImageUtils.loadTexture( 'graphon/ScreenFinal2Small.png' );
                            var materialStalk=new THREE.MeshBasicMaterial( { map: textureStalk } );
                            var geometryStalk = new THREE.BoxGeometry( 2*myUnitSz/3, myUnitSz*2, 2*myUnitSz/3 );
                            var cube0 = new THREE.Mesh(geometryStalk, materialStalk);
                            scene.add(cube0);
                            cube0.position.setX(unitX*myUnitSz);
                            cube0.position.setZ(unitZ*myUnitSz);
                            cube0.position.setY(myUnitSz);
                            
                            
                            
                            var cube2 = new THREE.Mesh(geometryBase, material1);
                            scene.add(cube2);
                            cube2.position.setX(unitX*myUnitSz);
                            cube2.position.setZ(unitZ*myUnitSz);
                            cube2.position.setY(16*myUnitSz/8);
                            //adding collision
                            var cubeGeometry = new THREE.BoxGeometry(myUnitSz, myUnitSz*2, myUnitSz);
                            //var wireMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe:true } );
                            var wireMaterial = new THREE.MeshBasicMaterial( { transparent: true, opacity: 0 } );
                            var CollidingCube = new THREE.Mesh( cubeGeometry, wireMaterial );
                            
                            allCollisionsArray.push(new collisionPlanarRecord( (unitX-1/2)*myUnitSz, (unitZ-1/2)*myUnitSz,
                                                                               (unitX+1/2)*myUnitSz, (unitZ+1/2)*myUnitSz,
                                                                               cube0.uuid,
                                                                               unitX, unitZ
                                                    )
                                                    );
                            CollidingCube.position.x = cube0.position.x;
                            CollidingCube.position.z = cube0.position.z;
                            CollidingCube.position.y = cube0.position.y;
                            
                            
                            objects.push(cube0);
                        }
                        /**
                         * place randomly objects over the field
                         * @returns {undefined}
                         */
                        function initObjects2() {
                            var farXBorder=-planewidth/2+1; var farYBorder=-planedepth/2+1;
                            var closeXBorder=planewidth/2-1; var closeYBorder=planedepth/2-1;
                            /*
                            addSingleNKI2(-20+1,-20+1,"1");
                            addSingleNKI2(20-1,20-1,"2");
                            */
                            var randXPosition = getRandomInt(farXBorder,closeXBorder);
                            var randYPosition = getRandomInt(farYBorder,closeYBorder);
                            console.log("(x="+randXPosition+";z="+randYPosition+")");
                            controls.getObject().position.x=randXPosition*myUnitSz;
                            controls.getObject().position.z=randYPosition*myUnitSz;
                            prevPosition.x = controls.getObject().position.x;
                            prevPosition.z = controls.getObject().position.z;
                            //randomly place items over the field. use NKI for this
                            for (var i=0; i<nkiNum; i++) {
                                var proceedCycle=false;
                                do { 
                                var randXPosition = getRandomInt(farXBorder,closeXBorder);
                                var randYPosition = getRandomInt(farYBorder,closeYBorder);
                                    if ((typeof allNKI[randXPosition]==="undefined")||(typeof allNKI[randXPosition][randYPosition]==="undefined")) {
                                        proceedCycle=false;
                                        var nki_sym=random_character();
                                        var nki_color = palette[getRandomInt(0,pLength)];
                                            var randNKI=getRandomInt(0,availableNKIindexes.length-1);
                                            var nkiDescr=availableNKIindexes[randNKI];
                                            availableNKIindexes.splice(randNKI,1);
                                        addSingleNKI2(randXPosition,randYPosition, nki_sym, nki_color);
                                        if (typeof allNKI[randXPosition]==="undefined") { allNKI[randXPosition]=[]; }
                                        allNKI[randXPosition][randYPosition] = new BasicNKI(randXPosition, randYPosition,nki_sym,nkiDescr);
                                        
                                    } else {
                                        //we already have NKI here, try again
                                        proceedCycle=true;
                                    }
                                } while (proceedCycle)
                            }
                            
                        }
                        
                        function initObjects() {
                            geometry = new THREE.BoxGeometry( 20, 20, 20 );
				for ( var i = 0, l = geometry.faces.length; i < l; i ++ ) {
					var face = geometry.faces[ i ];
					face.vertexColors[ 0 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
					face.vertexColors[ 1 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
					face.vertexColors[ 2 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
				}
				for ( var i = 0; i < 500; i ++ ) {
					material = new THREE.MeshPhongMaterial( { specular: 0xffffff, shading: THREE.FlatShading, vertexColors: THREE.VertexColors } );
					var mesh = new THREE.Mesh( geometry, material );
					mesh.position.x = Math.floor( Math.random() * 20 - 10 ) * 20;
					mesh.position.y = Math.floor( Math.random() * 20 ) * 20 + 10;
					mesh.position.z = Math.floor( Math.random() * 20 - 10 ) * 20;
					scene.add( mesh );
					material.color.setHSL( Math.random() * 0.2 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
					objects.push( mesh );
				}
                        }
                        //=============================
                        //here was a subroutine for skybox, but who needs a skybox when you have a cool fog which not even lags! 
                        
                        //-------------------------------
			// http://www.html5rocks.com/en/tutorials/pointerlock/intro/
                        //here comes an enigmatic PointerLock code. Too many callbacks for me.
			var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
			if ( havePointerLock ) {
				var element = document.body;
				var pointerlockchange = function ( event ) {

					if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {

						controlsEnabled = true;
						controls.enabled = true;
						blocker.style.display = 'none';

					} else {

						controls.enabled = false;
						blocker.style.display = '-webkit-box';
						blocker.style.display = '-moz-box';
						blocker.style.display = 'box';
						instructions.style.display = '';

					}

				};

				var pointerlockerror = function ( event ) {

					instructions.style.display = '';

				};

				// Hook pointer lock state change events
				document.addEventListener( 'pointerlockchange', pointerlockchange, false );
				document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
				document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

				document.addEventListener( 'pointerlockerror', pointerlockerror, false );
				document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
				document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

				instructions.addEventListener( 'click', function ( event ) {
					instructions.style.display = 'none';
					// Ask the browser to lock the pointer
					element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
                                        //Jovan says: I wonder, should I remove the fullscreen switching for Firefox. anyway, it's so much YOBA. Like in CRUZIS
                                        /*
					if ( /Firefox/i.test( navigator.userAgent ) ) {
						var fullscreenchange = function ( event ) {
							if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {
								document.removeEventListener( 'fullscreenchange', fullscreenchange );
								document.removeEventListener( 'mozfullscreenchange', fullscreenchange );
								element.requestPointerLock();
							}
						};
						document.addEventListener( 'fullscreenchange', fullscreenchange, false );
						document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );
						element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
						element.requestFullscreen();
					} else {
						element.requestPointerLock();
					}
                                        */
                                       element.requestPointerLock();

				}, false );

			} else {

				instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';

			}

			init();
			animate();

			var controlsEnabled = false;

			var moveForward = false;
			var moveBackward = false;
			var moveLeft = false;
			var moveRight = false;
			var canJump = false;

			var prevTime = performance.now();
			var velocity = new THREE.Vector3();

			function init() {

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );
				scene = new THREE.Scene();
				var light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 0.75 );
				light.position.set( 0.5, 1, 0.75 );
				scene.add( light );
				controls = new THREE.PointerLockControls( camera );
				scene.add( controls.getObject() );
				var onKeyDown = function ( event ) {
					switch ( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = true;
							break;

						case 37: // left
						case 65: // a
							moveLeft = true; break;

						case 40: // down
						case 83: // s
							moveBackward = true;
							break;

						case 39: // right
						case 68: // d
							moveRight = true;
							break;

						case 32: // space
							if ( canJump === true ) velocity.y += 350;
							canJump = false;
							break;

					}

				};

				var onKeyUp = function ( event ) {

					switch( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = false;
							break;

						case 37: // left
						case 65: // a
							moveLeft = false;
							break;

						case 40: // down
						case 83: // s
							moveBackward = false;
							break;

						case 39: // right
						case 68: // d
							moveRight = false;
							break;

					}

				};

				document.addEventListener( 'keydown', onKeyDown, false );
				document.addEventListener( 'keyup', onKeyUp, false );
                                // Set the rays for raycasting: one vector for every potential direction
                                // Yep, this.rays[i] gives us : 0 => forward, 1 => forward-left, 2 => left, ...
                                rays = [
                                      new THREE.Vector3(0, 0, 1), //forward
                                      new THREE.Vector3(1, 0, 1), //forward left
                                      new THREE.Vector3(1, 0, 0), //left
                                      new THREE.Vector3(1, 0, -1), //left backwards
                                      new THREE.Vector3(0, 0, -1), //backwards
                                      new THREE.Vector3(-1, 0, -1),//right backwards
                                      new THREE.Vector3(-1, 0, 0), //right
                                      new THREE.Vector3(-1, 0, 1)  //right forward
                                    ];
                                 bottomVector=new THREE.Vector3( 0, - 1, 0 ); //to down
				raycaster = new THREE.Raycaster( new THREE.Vector3(), bottomVector, 0, 10 );
                                
                                //===draw world===
                                renderer = new THREE.WebGLRenderer({alpha:true}) ;
				//renderer.setClearColor( 0xff0000 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );                                
                                planedepth=40; planewidth=40; 
                                nkiNum=20; allNKI = [];
                                
                                availableNKIindexes = [];
                                    var nkiBaseLength = nkicollection.length;
                                    for (var i=0; i<nkiBaseLength; i++) {availableNKIindexes[i]=i+1;}
				// floor
                                initFloor2();
				// objects
				//initObjects();
                                initObjects2();
				//
				

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}
                        
			function animate() {

				requestAnimationFrame( animate );

				if ( controlsEnabled ) {
					raycaster.ray.origin.copy( controls.getObject().position );
					raycaster.ray.origin.y -= 10;
                                        //isOnObject - a variable responsive for "falling" calculation. It is being processed separately,
                                        //due to its legacy nature. bottomVector is being called for it.
                                        var rotationVectorFunction = controls.getDirection();
                                        var rotationVectorValue=new THREE.Vector3(0.0,0.0,0.0);
                                        var rotationVectorValue2=rotationVectorFunction(rotationVectorValue);                                        
                                        raycaster.ray.direction = bottomVector;
					var intersections = raycaster.intersectObjects( objects );
                                            //http://webmaestro.fr/collisions-detection-three-js-raycasting/
					var isOnObject = intersections.length > 0;

					var time = performance.now();
					var delta = ( time - prevTime ) / 1000;

					velocity.x -= velocity.x * 10.0 * delta;
					velocity.z -= velocity.z * 10.0 * delta;
					velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

					if ( moveForward === true ) { 
                                            velocity.z -= 400.0 * delta; }
					if ( moveBackward === true ) { 
                                            velocity.z += 400.0 * delta; 
                                        }

					if ( moveLeft === true ) {
                                            velocity.x -= 400.0 * delta;
                                        }
					if ( moveRight ===true ) {
                                            velocity.x += 400.0 * delta;
                                        }

					if ( isOnObject === true ) {
						velocity.y = Math.max( 0, velocity.y );
                                               
						canJump = true;                                                
					}
                                        var xTranslation=velocity.x * delta;
                                        var yTranslation=velocity.y * delta;
                                        var zTranslation=velocity.z * delta;
                                        
                                            controls.getObject().translateX( xTranslation);
                                            controls.getObject().translateY( yTranslation);
                                            controls.getObject().translateZ( zTranslation);
                                        
                                        var collisionResult=checkCollisionGrid(controls.getObject().position.x, controls.getObject().position.z);
                                        if (collisionResult!==null) {
                                            console.log("found collision!");
                                            console.log(collisionResult);
                                            var NKI_line = nkicollection[(allNKI[collisionResult.intY][collisionResult.intX]).content];
                                            document.getElementById("info").innerHTML = NKI_line;
                                           
                                           controls.getObject().position.x = prevPosition.x;
                                           controls.getObject().position.z = prevPosition.z;
                                           /*
                                           if (moveForward===true) {
                                               console.log("canceled forward movement");
                                               moveForward=false;
                                           } else {
                                               if (moveBackward===true) {
                                                   console.log("canceled backwards movement");
                                                   moveBackward=false;
                                               } else {
                                                   if (moveLeft===true) {
                                                       console.log("canceled left movement");
                                                       moveLeft=false;
                                                   } else {
                                                       if (moveRight===true) {
                                                           console.log("canceled right movement");
                                                           moveRight=false;
                                                       } else {
                                                           console.log("nowhere to go?");
                                                       }
                                                   }
                                               }
                                           }
                                           */
                                        } else {
                                            
                                            prevPosition.x = controls.getObject().position.x;
                                            prevPosition.z = controls.getObject().position.z;
                                        }
					if ( controls.getObject().position.y < controlsHeight ) {

						velocity.y = 0;
						controls.getObject().position.y = controlsHeight;
						canJump = true;
					}

					prevTime = time;

				}

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>